/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
If you want to view the source, please visit the github repository.
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MisePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// src/types/index.ts
var DEFAULT_SETTINGS = {
  recipesFolder: "Life/Household/Kitchen/Recipes",
  mealPlanFolder: "Life/Household/Kitchen/Meal Plans",
  shoppingListFolder: "Life/Household/Shopping Lists",
  autoArchiveShoppingLists: "off",
  aisles: [
    { name: "Produce", keywords: ["lettuce", "tomato", "onion", "garlic", "pepper", "apple", "lemon", "lime", "orange", "banana", "potato", "carrot", "celery", "broccoli", "spinach"] },
    { name: "Dairy", keywords: ["milk", "cheese", "butter", "cream", "yogurt", "sour cream", "eggs"] },
    { name: "Meat", keywords: ["chicken", "beef", "pork", "steak", "ground", "bacon", "sausage", "turkey", "fish", "salmon", "shrimp"] },
    { name: "Bakery", keywords: ["bread", "buns", "tortillas", "rolls", "bagels"] },
    { name: "Pantry", keywords: ["pasta", "rice", "flour", "sugar", "oil", "vinegar", "sauce", "broth", "stock", "beans", "canned"] },
    { name: "Frozen", keywords: ["frozen", "ice cream"] },
    { name: "Beverages", keywords: ["soda", "juice", "water", "coffee", "tea"] }
  ],
  mealPlanInsertOptions: {
    includeLink: true,
    includeServings: false,
    includeTime: false,
    includeIngredientsInline: false,
    includeIngredientsCallout: false,
    includeSource: false
  }
};

// src/services/RecipeIndexer.ts
var import_obsidian = require("obsidian");

// src/parsers/IngredientParser.ts
var INGREDIENT_HEADER_PATTERNS = [
  /^##\s*ðŸ¥˜\s*ingredients?\s*$/im,
  /^##\s*ingredients?\s*ðŸ¥˜?\s*$/im,
  /^##\s*ingredients?\s*$/im
];
var SECTION_END_PATTERNS = [
  /^##\s+/,
  // Any H2 header
  /^#\s+/,
  // Any H1 header
  /^---\s*$/
  // Horizontal rule
];
function parseIngredients(content) {
  const headerMatch = findIngredientHeader(content);
  if (!headerMatch) {
    return [];
  }
  const startIndex = headerMatch.index + headerMatch.match.length;
  const endIndex = findSectionEnd(content, startIndex);
  const ingredientSection = content.slice(startIndex, endIndex);
  return extractIngredientsFromSection(ingredientSection);
}
function findIngredientHeader(content) {
  for (const pattern of INGREDIENT_HEADER_PATTERNS) {
    const match = content.match(pattern);
    if (match && match.index !== void 0) {
      return {
        index: match.index,
        match: match[0]
      };
    }
  }
  return null;
}
function findSectionEnd(content, startIndex) {
  const remaining = content.slice(startIndex);
  const lines = remaining.split("\n");
  let charCount = 0;
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    if (i > 0) {
      for (const pattern of SECTION_END_PATTERNS) {
        if (pattern.test(line)) {
          return startIndex + charCount;
        }
      }
    }
    charCount += line.length + 1;
  }
  return content.length;
}
function extractIngredientsFromSection(section) {
  const lines = section.split("\n");
  const ingredients = [];
  for (const line of lines) {
    const cleaned = cleanIngredientLine(line);
    if (cleaned && !isSubHeader(cleaned)) {
      ingredients.push(cleaned);
    }
  }
  return ingredients;
}
function isSubHeader(line) {
  if (/^\*\*[^*]+\*\*$/.test(line)) return true;
  if (/^\*[^*]+\*$/.test(line)) return true;
  if (/^###/.test(line)) return true;
  if (/^_{2,}$/.test(line) || /^={2,}$/.test(line)) return true;
  return false;
}
function cleanIngredientLine(line) {
  let cleaned = line.trim();
  if (!cleaned) return "";
  if (/^[-_*]{3,}$/.test(cleaned)) return "";
  cleaned = cleaned.replace(/^[-*+]\s*\[[x ]\]\s*/i, "");
  cleaned = cleaned.replace(/^[-*+]\s+/, "");
  cleaned = cleaned.replace(/^\d+[.)]\s*/, "");
  cleaned = cleaned.trim();
  cleaned = cleaned.replace(/\[[x ]\]/gi, "").trim();
  return cleaned;
}

// src/parsers/FrontmatterParser.ts
function parseTime(timeStr) {
  if (timeStr === void 0 || timeStr === null || timeStr === "") {
    return null;
  }
  if (typeof timeStr === "number") {
    return timeStr;
  }
  const str = String(timeStr).toLowerCase().trim();
  if (/^\d+$/.test(str)) {
    return parseInt(str, 10);
  }
  let totalMinutes = 0;
  const hourMatch = str.match(/(\d+)\s*(?:hours?|hrs?|h)/);
  if (hourMatch) {
    totalMinutes += parseInt(hourMatch[1], 10) * 60;
  }
  const minMatch = str.match(/(\d+)\s*(?:minutes?|mins?|m(?!o))/);
  if (minMatch) {
    totalMinutes += parseInt(minMatch[1], 10);
  }
  return totalMinutes > 0 ? totalMinutes : null;
}
function parseCategory(category) {
  if (!category) {
    return "Uncategorized";
  }
  const normalized = category.trim();
  const validCategories = [
    "Main",
    "Breakfast",
    "Appetizer",
    "Side",
    "Dessert",
    "Beverage",
    "Snack"
  ];
  if (validCategories.includes(normalized)) {
    return normalized;
  }
  return "Uncategorized";
}
function parseRating(rating) {
  if (rating === void 0 || rating === null || rating === "") {
    return null;
  }
  const num = typeof rating === "number" ? rating : parseInt(String(rating), 10);
  if (isNaN(num) || num < 1 || num > 5) {
    return null;
  }
  return num;
}
function parseDietaryFlags(flags) {
  if (!flags || !Array.isArray(flags)) {
    return [];
  }
  const validFlags = [
    "crohns-safe",
    "low-fiber",
    "high-fiber",
    "high-protein",
    "high-carb",
    "low-carb",
    "dairy-free",
    "gluten-free",
    "vegetarian",
    "vegan",
    "keto",
    "paleo"
  ];
  return flags.map((f) => f.toLowerCase().trim()).filter((f) => validFlags.includes(f));
}

// src/utils/helpers.ts
function debounce(func, wait) {
  let timeout = null;
  return function(...args) {
    if (timeout) {
      clearTimeout(timeout);
    }
    timeout = setTimeout(() => {
      func.apply(this, args);
    }, wait);
  };
}

// src/utils/constants.ts
var PLUGIN_NAME = "Mise";

// src/services/RecipeIndexer.ts
var DEBUG = false;
var RecipeIndexer = class extends import_obsidian.Events {
  constructor(app, settings) {
    super();
    this.recipes = /* @__PURE__ */ new Map();
    this.eventRefs = [];
    this.isInitialized = false;
    this.app = app;
    this.settings = settings;
  }
  /**
   * Initialize the indexer and perform initial scan
   */
  async initialize() {
    const startTime = performance.now();
    await this.scanVault();
    this.registerEventHandlers();
    this.isInitialized = true;
    const elapsed = (performance.now() - startTime).toFixed(0);
    console.log(`${PLUGIN_NAME}: Indexed ${this.recipes.size} recipes in ${elapsed}ms`);
    this.trigger("index-ready", { count: this.recipes.size });
  }
  /**
   * Scan the vault for all recipe files
   */
  async scanVault() {
    const recipesFolder = this.settings.recipesFolder;
    const folder = this.app.vault.getAbstractFileByPath(recipesFolder);
    if (!folder || !(folder instanceof import_obsidian.TFolder)) {
      console.warn(`${PLUGIN_NAME}: Recipes folder not found: ${recipesFolder}`);
      return;
    }
    const files = this.getMarkdownFilesRecursive(folder);
    for (const file of files) {
      const recipe = await this.buildRecipeFromFile(file);
      if (recipe) {
        this.recipes.set(file.path, recipe);
      }
    }
  }
  /**
   * Recursively get all markdown files in a folder
   */
  getMarkdownFilesRecursive(folder) {
    const files = [];
    for (const child of folder.children) {
      if (child instanceof import_obsidian.TFile && child.extension === "md") {
        files.push(child);
      } else if (child instanceof import_obsidian.TFolder) {
        files.push(...this.getMarkdownFilesRecursive(child));
      }
    }
    return files;
  }
  /**
   * Build a Recipe object from a file
   */
  async buildRecipeFromFile(file) {
    var _a;
    try {
      const cache = this.app.metadataCache.getFileCache(file);
      const frontmatter = (cache == null ? void 0 : cache.frontmatter) || {};
      const content = await this.app.vault.cachedRead(file);
      const recipe = {
        path: file.path,
        title: this.extractTitle(file, frontmatter, content),
        folder: ((_a = file.parent) == null ? void 0 : _a.name) || "",
        category: parseCategory(frontmatter.category),
        tags: Array.isArray(frontmatter.tags) ? frontmatter.tags : [],
        rating: parseRating(frontmatter.rating),
        servings: String(frontmatter.servings || ""),
        prepTime: parseTime(frontmatter.prep_time),
        cookTime: parseTime(frontmatter.cook_time),
        source: frontmatter.source || null,
        image: frontmatter.image || null,
        dietaryFlags: parseDietaryFlags(frontmatter.dietary_flags || frontmatter.dietaryFlags),
        ingredients: parseIngredients(content),
        lastModified: file.stat.mtime
      };
      if (frontmatter.calories || frontmatter.protein || frontmatter.carbs || frontmatter.fat) {
        recipe.nutrition = {
          calories: frontmatter.calories,
          protein: frontmatter.protein,
          carbs: frontmatter.carbs,
          fat: frontmatter.fat,
          fiber: frontmatter.fiber
        };
      }
      return recipe;
    } catch (error) {
      console.error(`${PLUGIN_NAME}: Error parsing recipe ${file.path}:`, error);
      return null;
    }
  }
  /**
   * Extract title from file (prefer H1, fall back to frontmatter title, then filename)
   */
  extractTitle(file, frontmatter, content) {
    if (frontmatter.title) {
      return frontmatter.title;
    }
    const h1Match = content.match(/^#\s+(.+)$/m);
    if (h1Match) {
      return h1Match[1].trim();
    }
    return file.basename;
  }
  /**
   * Register vault event handlers
   */
  registerEventHandlers() {
    const debouncedModify = debounce((file) => {
      this.handleFileModify(file);
    }, 300);
    const createRef = this.app.vault.on("create", (file) => {
      if (file instanceof import_obsidian.TFile && this.isRecipeFile(file) && this.isInitialized) {
        this.handleFileCreate(file);
      }
    });
    this.eventRefs.push(createRef);
    const modifyRef = this.app.vault.on("modify", (file) => {
      if (file instanceof import_obsidian.TFile && this.isRecipeFile(file) && this.isInitialized) {
        debouncedModify(file);
      }
    });
    this.eventRefs.push(modifyRef);
    const deleteRef = this.app.vault.on("delete", (file) => {
      if (file instanceof import_obsidian.TFile && this.recipes.has(file.path)) {
        this.handleFileDelete(file);
      }
    });
    this.eventRefs.push(deleteRef);
    const renameRef = this.app.vault.on("rename", (file, oldPath) => {
      if (file instanceof import_obsidian.TFile && this.isInitialized) {
        this.handleFileRename(file, oldPath);
      }
    });
    this.eventRefs.push(renameRef);
    const resolveRef = this.app.metadataCache.on("resolve", (file) => {
      if (file instanceof import_obsidian.TFile && this.isRecipeFile(file) && this.isInitialized) {
        if (this.recipes.has(file.path)) {
          setTimeout(() => debouncedModify(file), 50);
        }
      }
    });
    this.eventRefs.push(resolveRef);
  }
  /**
   * Check if a file is in the recipes folder
   */
  isRecipeFile(file) {
    return file.path.startsWith(this.settings.recipesFolder) && file.extension === "md";
  }
  /**
   * Handle file creation
   */
  async handleFileCreate(file) {
    const recipe = await this.buildRecipeFromFile(file);
    if (recipe) {
      this.recipes.set(file.path, recipe);
      this.trigger("recipe-added", recipe);
      if (DEBUG) console.log(`${PLUGIN_NAME}: Added: ${recipe.title}`);
    }
  }
  /**
   * Handle file modification
   */
  async handleFileModify(file) {
    const existingRecipe = this.recipes.get(file.path);
    const recipe = await this.buildRecipeFromFile(file);
    if (recipe) {
      this.recipes.set(file.path, recipe);
      if (existingRecipe) {
        this.trigger("recipe-updated", recipe);
        if (DEBUG) console.log(`${PLUGIN_NAME}: Updated: ${recipe.title}`);
      } else {
        this.trigger("recipe-added", recipe);
        if (DEBUG) console.log(`${PLUGIN_NAME}: Added: ${recipe.title}`);
      }
    }
  }
  /**
   * Handle file deletion
   */
  handleFileDelete(file) {
    const recipe = this.recipes.get(file.path);
    if (recipe) {
      this.recipes.delete(file.path);
      this.trigger("recipe-deleted", file.path);
      if (DEBUG) console.log(`${PLUGIN_NAME}: Removed: ${recipe.title}`);
    }
  }
  /**
   * Handle file rename/move
   */
  async handleFileRename(file, oldPath) {
    const wasRecipe = this.recipes.has(oldPath);
    const isNowRecipe = this.isRecipeFile(file);
    if (wasRecipe) {
      this.recipes.delete(oldPath);
      this.trigger("recipe-deleted", oldPath);
      if (DEBUG) console.log(`${PLUGIN_NAME}: Removed old path: ${oldPath}`);
    }
    if (isNowRecipe) {
      const recipe = await this.buildRecipeFromFile(file);
      if (recipe) {
        this.recipes.set(file.path, recipe);
        this.trigger("recipe-added", recipe);
        if (DEBUG) console.log(`${PLUGIN_NAME}: Added at new path: ${file.path}`);
      }
    }
  }
  /**
   * Get all indexed recipes
   */
  getRecipes() {
    return Array.from(this.recipes.values());
  }
  /**
   * Get a specific recipe by path
   */
  getRecipe(path) {
    return this.recipes.get(path);
  }
  /**
   * Get recipe count
   */
  getCount() {
    return this.recipes.size;
  }
  /**
   * Search recipes by title or ingredient
   */
  search(query) {
    const lowerQuery = query.toLowerCase();
    return this.getRecipes().filter(
      (recipe) => recipe.title.toLowerCase().includes(lowerQuery) || recipe.ingredients.some((ing) => ing.toLowerCase().includes(lowerQuery))
    );
  }
  /**
   * Filter recipes by category
   */
  filterByCategory(category) {
    return this.getRecipes().filter((recipe) => recipe.category === category);
  }
  /**
   * Filter recipes by dietary flag
   */
  filterByDietaryFlag(flag) {
    return this.getRecipes().filter((recipe) => recipe.dietaryFlags.includes(flag));
  }
  /**
   * Update settings reference (called when settings change)
   */
  updateSettings(settings) {
    const oldFolder = this.settings.recipesFolder;
    this.settings = settings;
    if (oldFolder !== settings.recipesFolder) {
      console.log(`${PLUGIN_NAME}: Recipes folder changed, rescanning...`);
      this.recipes.clear();
      this.scanVault();
    }
  }
  /**
   * Clean up event listeners
   */
  destroy() {
    for (const ref of this.eventRefs) {
      this.app.vault.offref(ref);
    }
    this.eventRefs = [];
    this.recipes.clear();
  }
};

// src/services/MealPlanService.ts
var MealPlanService = class {
  constructor(app, settings, indexer) {
    this.app = app;
    this.settings = settings;
    this.indexer = indexer;
  }
  /**
   * Get the current month's meal plan
   */
  async getCurrentPlan() {
    console.log("MealPlanService: Not yet implemented");
    return null;
  }
  /**
   * Add a recipe to a specific day/meal
   */
  async addMeal(date, meal, recipePath) {
    console.log("MealPlanService.addMeal: Not yet implemented");
  }
};

// src/services/ShoppingListService.ts
var ShoppingListService = class {
  constructor(app, settings, indexer) {
    this.app = app;
    this.settings = settings;
    this.indexer = indexer;
  }
  /**
   * Generate a shopping list for a date range
   */
  async generateList(startDate, endDate, mode = "normal") {
    console.log("ShoppingListService.generateList: Not yet implemented");
    return {
      generatedAt: (/* @__PURE__ */ new Date()).toISOString(),
      dateRange: { start: startDate, end: endDate },
      mode,
      aisles: []
    };
  }
  /**
   * Write shopping list to a file
   */
  async writeListToFile(list) {
    console.log("ShoppingListService.writeListToFile: Not yet implemented");
    return "";
  }
};

// src/ui/settings/MiseSettingsTab.ts
var import_obsidian3 = require("obsidian");

// src/ui/components/FolderSuggest.ts
var import_obsidian2 = require("obsidian");
var FolderSuggest = class extends import_obsidian2.AbstractInputSuggest {
  constructor(app, inputEl) {
    super(app, inputEl);
    this.textInput = inputEl;
    this.folders = this.getFolders();
  }
  getFolders() {
    return this.app.vault.getAllLoadedFiles().filter((f) => f instanceof import_obsidian2.TFolder).sort((a, b) => a.path.localeCompare(b.path));
  }
  getSuggestions(query) {
    const lowerQuery = query.toLowerCase();
    return this.folders.filter(
      (folder) => folder.path.toLowerCase().includes(lowerQuery)
    );
  }
  renderSuggestion(folder, el) {
    el.createEl("div", { text: folder.path, cls: "mise-folder-suggestion" });
  }
  selectSuggestion(folder) {
    this.textInput.value = folder.path;
    this.textInput.trigger("input");
    this.close();
  }
};

// src/ui/settings/MiseSettingsTab.ts
var MiseSettingsTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h1", { text: "Mise Settings" });
    containerEl.createEl("p", {
      text: "Configure your culinary operating system.",
      cls: "mise-settings-description"
    });
    containerEl.createEl("h2", { text: "\u{1F4C1} Folder Paths" });
    new import_obsidian3.Setting(containerEl).setName("Recipes Folder").setDesc("The folder containing your recipe markdown files.").addText((text) => {
      text.setPlaceholder("Type to search folders...").setValue(this.plugin.settings.recipesFolder).onChange(async (value) => {
        this.plugin.settings.recipesFolder = value;
        await this.plugin.saveSettings();
      });
      new FolderSuggest(this.app, text.inputEl);
    });
    new import_obsidian3.Setting(containerEl).setName("Meal Plan Folder").setDesc("The folder where meal plan files are stored.").addText((text) => {
      text.setPlaceholder("Type to search folders...").setValue(this.plugin.settings.mealPlanFolder).onChange(async (value) => {
        this.plugin.settings.mealPlanFolder = value;
        await this.plugin.saveSettings();
      });
      new FolderSuggest(this.app, text.inputEl);
    });
    new import_obsidian3.Setting(containerEl).setName("Shopping List Folder").setDesc("The folder where shopping lists are generated.").addText((text) => {
      text.setPlaceholder("Type to search folders...").setValue(this.plugin.settings.shoppingListFolder).onChange(async (value) => {
        this.plugin.settings.shoppingListFolder = value;
        await this.plugin.saveSettings();
      });
      new FolderSuggest(this.app, text.inputEl);
    });
    containerEl.createEl("h2", { text: "\u{1F6D2} Shopping Lists" });
    new import_obsidian3.Setting(containerEl).setName("Auto-archive Shopping Lists").setDesc("What to do with old shopping lists when generating new ones.").addDropdown((dropdown) => dropdown.addOption("off", "Off - Keep all lists in place").addOption("on", "On - Automatically archive").addOption("ask", "Ask every time").setValue(this.plugin.settings.autoArchiveShoppingLists).onChange(async (value) => {
      this.plugin.settings.autoArchiveShoppingLists = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h2", { text: "\u{1F4C5} Meal Plan Insertion" });
    containerEl.createEl("p", {
      text: "Configure what gets inserted when you add a recipe to a meal plan.",
      cls: "mise-settings-description"
    });
    const insertOptions = this.plugin.settings.mealPlanInsertOptions;
    new import_obsidian3.Setting(containerEl).setName("Include Servings").setDesc("Add servings info when inserting a recipe.").addToggle((toggle) => toggle.setValue(insertOptions.includeServings).onChange(async (value) => {
      this.plugin.settings.mealPlanInsertOptions.includeServings = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Include Prep/Cook Time").setDesc("Add time information when inserting a recipe.").addToggle((toggle) => toggle.setValue(insertOptions.includeTime).onChange(async (value) => {
      this.plugin.settings.mealPlanInsertOptions.includeTime = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Include Ingredients (Inline)").setDesc("Add a comma-separated ingredient list.").addToggle((toggle) => toggle.setValue(insertOptions.includeIngredientsInline).onChange(async (value) => {
      this.plugin.settings.mealPlanInsertOptions.includeIngredientsInline = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Include Ingredients (Callout)").setDesc("Add ingredients in a collapsible callout block.").addToggle((toggle) => toggle.setValue(insertOptions.includeIngredientsCallout).onChange(async (value) => {
      this.plugin.settings.mealPlanInsertOptions.includeIngredientsCallout = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Include Source Link").setDesc("Add the source URL if available.").addToggle((toggle) => toggle.setValue(insertOptions.includeSource).onChange(async (value) => {
      this.plugin.settings.mealPlanInsertOptions.includeSource = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h2", { text: "\u{1F3EA} Aisle Configuration" });
    containerEl.createEl("p", {
      text: "Customize how ingredients are grouped into aisles. (Coming in a future update)",
      cls: "mise-settings-description"
    });
    const aisleList = containerEl.createEl("div", { cls: "mise-aisle-list" });
    for (const aisle of this.plugin.settings.aisles) {
      aisleList.createEl("p", {
        text: `\u2022 ${aisle.name}: ${aisle.keywords.slice(0, 5).join(", ")}...`,
        cls: "mise-settings-description"
      });
    }
    containerEl.createEl("h2", { text: "\u2699\uFE0F Advanced" });
    new import_obsidian3.Setting(containerEl).setName("Reset to Defaults").setDesc("Reset all settings to their default values.").addButton((button) => button.setButtonText("Reset").setWarning().onClick(async () => {
      this.plugin.settings = { ...DEFAULT_SETTINGS };
      await this.plugin.saveSettings();
      this.display();
    }));
  }
};

// src/main.ts
var MisePlugin = class extends import_obsidian4.Plugin {
  async onload() {
    console.log(`${PLUGIN_NAME}: Loading plugin...`);
    await this.loadSettings();
    this.indexer = new RecipeIndexer(this.app, this.settings);
    this.mealPlanService = new MealPlanService(this.app, this.settings, this.indexer);
    this.shoppingListService = new ShoppingListService(this.app, this.settings, this.indexer);
    this.addSettingTab(new MiseSettingsTab(this.app, this));
    this.addCommand({
      id: "open-cookbook",
      name: "Open Cookbook",
      callback: () => {
        console.log(`${PLUGIN_NAME}: Open Cookbook command (not yet implemented)`);
      }
    });
    this.addCommand({
      id: "generate-shopping-list",
      name: "Generate Shopping List",
      callback: () => {
        console.log(`${PLUGIN_NAME}: Generate Shopping List command (not yet implemented)`);
      }
    });
    this.app.workspace.onLayoutReady(async () => {
      await this.indexer.initialize();
    });
    console.log(`${PLUGIN_NAME}: Plugin loaded.`);
  }
  async onunload() {
    var _a;
    console.log(`${PLUGIN_NAME}: Unloading plugin...`);
    (_a = this.indexer) == null ? void 0 : _a.destroy();
    console.log(`${PLUGIN_NAME}: Plugin unloaded.`);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
